use serde::{Deserialize, Serialize};
use std::{
    collections::BTreeMap,
    ops::{Sub, SubAssign},
};
use time::OffsetDateTime;


#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Metadata {
    // Name must be unique within a namespace. Is required when creating resources, although some
    // resources may allow a client to request the generation of an appropriate name automatically.
    // Name is primarily intended for creation idempotence and configuration definition. Cannot be
    // updated. More info:
    // https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default)]
    pub name: String,

    #[serde(default)]
    pub namespace: String,


    // CreationTimestamp is a timestamp representing the server time when this object was created.
    // It is not guaranteed to be set in happens-before order across separate operations. Clients
    // may not set this value. It is represented in RFC3339 form and is in UTC.
    #[serde(with = "time::serde::rfc3339::option")]
    pub creation_timestamp: Option<OffsetDateTime>,
    // DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.

// Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    pub deletion_timestamp: Option<OffsetDateTime>,

    // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default)]
    pub labels: BTreeMap<String,String>,

    // UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
    //
    // Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
    #[serde(default)]
    pub uid: String,

    // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default)]
    pub annotations: BTreeMap<String, String>,

    // A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
    #[serde(default)]
    pub generation: u64,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct PodResource {
    pub metadata: Metadata,
    pub spec: PodSpec,
    pub status: PodStatus,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodSpec {
    pub node_name: Option<String>,
    pub scheduler_name: Option<String>,
    /// The resources that the pod will use
    /// This is a simplification, really this should be per container in the pod, but that doesn't
    /// impact things really.
    pub resources: Option<ResourceRequirements>,

    pub containers: Vec<Container>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct Container {
    pub name: String,
    pub image: String,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodStatus {}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ResourceRequirements {
    /// What a pod/container is guaranteed to have (minimums).
    pub requests: Option<ResourceQuantities>,
    /// What a pod/container cannot use more than (maximums).
    pub limits: Option<ResourceQuantities>,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ResourceQuantities {
    /// Number of cpu cores.
    pub cpu_cores: Option<Quantity>,
    /// Amount of memory (in megabytes).
    pub memory_mb: Option<Quantity>,
    /// Number of pods.
    pub pods: Option<Quantity>,
}

impl Sub for ResourceQuantities {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        Self {
            cpu_cores: Some(
                self.cpu_cores
                    .unwrap_or_default()
                    .to_int()
                    .saturating_sub(rhs.cpu_cores.unwrap_or_default().to_int())
                    .into(),
            ),
            memory_mb: Some(
                self.memory_mb
                    .unwrap_or_default()
                    .to_int()
                    .saturating_sub(rhs.memory_mb.unwrap_or_default().to_int())
                    .into(),
            ),
            pods: Some(
                self.pods
                    .unwrap_or_default()
                    .to_int()
                    .saturating_sub(rhs.pods.unwrap_or_default().to_int())
                    .into(),
            ),
        }
    }
}

impl SubAssign for ResourceQuantities {
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.clone() - rhs;
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ReplicaSetResource {
    pub metadata: Metadata,
    pub spec: ReplicaSetSpec,
    pub status: ReplicaSetStatus,
}

impl ReplicaSetResource {
    pub fn pods(&self) -> Vec<String> {
        (0..self.status.replicas)
            .map(|i| format!("{}-{}", self.metadata.name, i))
            .collect()
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReplicaSetSpec {
    pub replicas: Option<u32>,
    // Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
    pub selector: LabelSelector,
    pub template: PodTemplateSpec,
    // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
    #[serde(default)]
    pub min_ready_seconds: u32,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct PodTemplateSpec {
    pub metadata: Metadata,
    pub spec: PodSpec,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReplicaSetStatus {
    pub replicas: u32,
    // The number of available replicas (ready for at least minReadySeconds) for this replica set.
    pub available_replicas: u32,
    // ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
    #[serde(default)]
    pub observed_generation: u64,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct DeploymentResource {
    pub metadata: Metadata,
    pub spec: DeploymentSpec,
    pub status: DeploymentStatus,
}

impl DeploymentResource {
    pub fn replicasets(&self) -> Vec<String> {
        vec![self.metadata.name.clone()]
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeploymentSpec {
    pub replicas: u32,
    // Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
    pub selector: LabelSelector,
    pub template: PodTemplateSpec,
    // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
    #[serde(default)]
    pub min_ready_seconds: u32,

    // The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
    #[serde(default)]
    pub revision_history_limit:u32,

    #[serde(default)]
    pub paused: bool,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct DeploymentStatus {}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LabelSelector{
    // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    pub match_labels:BTreeMap<String,String>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct StatefulSetResource {
    pub metadata: Metadata,
    pub replicas: u32,
}

impl StatefulSetResource {
    pub fn pods(&self) -> Vec<String> {
        (0..self.replicas)
            .map(|i| format!("{}-{}", self.metadata.name, i))
            .collect()
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NodeResource {
    pub metadata: Metadata,
    pub spec: NodeSpec,
    pub status: NodeStatus,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NodeSpec {}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NodeStatus {
    /// The total resources of the node.
    #[serde(default)]
    pub capacity: ResourceQuantities,

    /// The total resources of the node.
    #[serde(default)]
    pub allocatable: ResourceQuantities,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Quantity {
    Str(String),
    Int(u32),
}

impl Default for Quantity {
    fn default() -> Self {
        Self::Int(0)
    }
}

impl Quantity {
    pub fn to_int(&self) -> u32 {
        match self {
            Quantity::Str(s) => {
                let (digit, unit) = s.split_once(char::is_alphabetic).unwrap();
                let digit = digit.parse().unwrap();
                match unit {
                    u => panic!("unhandled unit {u}"),
                };
                digit
            }
            Quantity::Int(i) => *i,
        }
    }
}

impl From<u32> for Quantity {
    fn from(value: u32) -> Self {
        Quantity::Int(value)
    }
}
