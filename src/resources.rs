use serde::{Deserialize, Serialize};
use std::{
    collections::BTreeMap,
    ops::{Sub, SubAssign},
};
use time::OffsetDateTime;


#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Metadata {
    // Name must be unique within a namespace. Is required when creating resources, although some
    // resources may allow a client to request the generation of an appropriate name automatically.
    // Name is primarily intended for creation idempotence and configuration definition. Cannot be
    // updated. More info:
    // https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    #[serde(default)]
    pub name: String,

    #[serde(default)]
    pub namespace: String,


    // CreationTimestamp is a timestamp representing the server time when this object was created.
    // It is not guaranteed to be set in happens-before order across separate operations. Clients
    // may not set this value. It is represented in RFC3339 form and is in UTC.
    #[serde(with = "time::serde::rfc3339::option")]
    pub creation_timestamp: Option<OffsetDateTime>,

    // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    #[serde(default)]
    pub labels: BTreeMap<String,String>,

    // UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
    //
    // Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
    #[serde(default)]
    pub uid: String,

    // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    #[serde(default)]
    pub annotations: BTreeMap<String, String>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct PodResource {
    pub metadata: Metadata,
    pub spec: PodSpec,
    pub status: PodStatus,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodSpec {
    pub node_name: Option<String>,
    pub scheduler_name: Option<String>,
    /// The resources that the pod will use
    /// This is a simplification, really this should be per container in the pod, but that doesn't
    /// impact things really.
    pub resources: Option<ResourceRequirements>,

    pub containers: Vec<Container>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct Container {
    pub name: String,
    pub image: String,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct PodStatus {}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ResourceRequirements {
    /// What a pod/container is guaranteed to have (minimums).
    pub requests: Option<ResourceQuantities>,
    /// What a pod/container cannot use more than (maximums).
    pub limits: Option<ResourceQuantities>,
}

#[derive(Clone, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ResourceQuantities {
    /// Number of cpu cores.
    pub cpu_cores: Option<Quantity>,
    /// Amount of memory (in megabytes).
    pub memory_mb: Option<Quantity>,
    /// Number of pods.
    pub pods: Option<Quantity>,
}

impl Sub for ResourceQuantities {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        Self {
            cpu_cores: Some(
                self.cpu_cores
                    .unwrap_or_default()
                    .to_int()
                    .saturating_sub(rhs.cpu_cores.unwrap_or_default().to_int())
                    .into(),
            ),
            memory_mb: Some(
                self.memory_mb
                    .unwrap_or_default()
                    .to_int()
                    .saturating_sub(rhs.memory_mb.unwrap_or_default().to_int())
                    .into(),
            ),
            pods: Some(
                self.pods
                    .unwrap_or_default()
                    .to_int()
                    .saturating_sub(rhs.pods.unwrap_or_default().to_int())
                    .into(),
            ),
        }
    }
}

impl SubAssign for ResourceQuantities {
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.clone() - rhs;
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ReplicaSetResource {
    pub metadata: Metadata,
    pub spec: ReplicaSetSpec,
    pub status: ReplicaSetStatus,
}

impl ReplicaSetResource {
    pub fn pods(&self) -> Vec<String> {
        (0..self.status.replicas)
            .map(|i| format!("{}-{}", self.metadata.name, i))
            .collect()
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReplicaSetSpec {
    pub replicas: Option<u32>,
    // Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
    pub selector: LabelSelector,
    pub template: PodTemplateSpec,
    // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
    #[serde(default)]
    pub min_ready_seconds: u32,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct PodTemplateSpec {
    pub metadata: Metadata,
    pub spec: PodSpec,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReplicaSetStatus {
    pub replicas: u32,
    // The number of available replicas (ready for at least minReadySeconds) for this replica set.
    pub available_replicas: u32,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct DeploymentResource {
    pub metadata: Metadata,
    pub spec: DeploymentSpec,
    pub status: DeploymentStatus,
}

impl DeploymentResource {
    pub fn replicasets(&self) -> Vec<String> {
        vec![self.metadata.name.clone()]
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DeploymentSpec {
    pub replicas: u32,
    // Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment. It must match the pod template's labels.
    pub selector: LabelSelector,
    pub template: PodTemplateSpec,
    // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
    #[serde(default)]
    pub min_ready_seconds: u32,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct DeploymentStatus {}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct LabelSelector{
    // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    pub match_labels:BTreeMap<String,String>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct StatefulSetResource {
    pub metadata: Metadata,
    pub replicas: u32,
}

impl StatefulSetResource {
    pub fn pods(&self) -> Vec<String> {
        (0..self.replicas)
            .map(|i| format!("{}-{}", self.metadata.name, i))
            .collect()
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NodeResource {
    pub metadata: Metadata,
    pub spec: NodeSpec,
    pub status: NodeStatus,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NodeSpec {}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct NodeStatus {
    /// The total resources of the node.
    #[serde(default)]
    pub capacity: ResourceQuantities,

    /// The total resources of the node.
    #[serde(default)]
    pub allocatable: ResourceQuantities,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Quantity {
    Str(String),
    Int(u32),
}

impl Default for Quantity {
    fn default() -> Self {
        Self::Int(0)
    }
}

impl Quantity {
    pub fn to_int(&self) -> u32 {
        match self {
            Quantity::Str(s) => {
                let (digit, unit) = s.split_once(char::is_alphabetic).unwrap();
                let digit = digit.parse().unwrap();
                match unit {
                    u => panic!("unhandled unit {u}"),
                };
                digit
            }
            Quantity::Int(i) => *i,
        }
    }
}

impl From<u32> for Quantity {
    fn from(value: u32) -> Self {
        Quantity::Int(value)
    }
}
